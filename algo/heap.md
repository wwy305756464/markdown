# Heap

heap就像一个店员记住了所有商品所对应的价格，所以在顾客问某个商品的价格时，店员只需要O(1)的时间给出答案。最大的优点是把数据的储存和查找的时间大大降低到常数时间，代价是消耗较多的内存。

## 散射函数

* 将输入映射到数字
* 散列函数必须满足的一些要求：
  * 一致性，输入所映射的数字必须每次都保持一致
  * 不同的输入应该映射到不同的数字中（理想情况）

## 散列表(hash table)

hash table 是由散列函数和数组组成的数据结构，它使用散列函数来决定元素的存储位置，用数组来储存数据。散列表由键（key）和值（value）组成，将键映射到值。

### 应用案例

#### 创建

```c++
unordered_map<int, string> hash  // unordered_map<key, val> hash
hash[0] = "abc"
hash[1] = "bcd"
```

插入过程：

1. 得到key
2. 通过hash函数得到hash值
3. 得到index，一般是hash值对内存总量求模
4. 在内存内存放key和value

#### 查找

```c++
if (hash.find(1) != hash.end()){
		...
}
```

取值过程：

1. 得到key
2. 通过hash函数得到hash值
3. 得到index
4. 比较index对应的内部元素是否与key相等，比较所有的index，如果都不相等则没有找到
5. 去除相等记录的value

#### 防止重复

``` python
voted = {}   ## python中创建hash
def check_voter(name):
    if voted.get(name):  ## 检测value是否已经存在
        print("Kick them out!")
    else:
        voted[name] = True  ## 如果不存在，则将元素加入hash中
        print("Let them vote!")
```

#### 用作缓存

访问网页的原理：

1. 向服务器发出请求
2. 服务器做些处理，生成网页并将其发送给你
3. 用户获得一个网页

如果我们多次向服务器发送相同的请求，服务器会将你这些请求和请求得到的网页记住，即不让服务器去生成主页，而是将主页储存在缓存区域里，这样在你需要的时候可以直接发送给用户。这样子，省略了服务器做处理这一步。缓存是一种常见的加速方式，所有大型网站都会使用缓存，缓存的数据就是储存在hash中。

``` python
cache = {}
def get_page(url):
    if cache.get(url):
        return cache[url]  ## 返回缓存的数据
    else:
        data = get_data_from_server(url)
        cache[url] = data
        return data
```

### 冲突

实际情况中，散射函数基本上不可能将不同的key映射到数组的不同位置，这时会有冲突的发生，即给两个key分配到了同一个位置。

想要避免冲突，如果两个key映射到了同一个位置，那么我们就在这个位置储存一个链表。在需要查询时，速度会慢些。如果这个链表很短，那么搜索的时间很短。所以我们需要创建好的散射函数来减少冲突。

### 性能

|      | Hash（平均） | Hash（最坏） | 数组 | 链表 |
| :--: | :----------: | :----------: | :--: | :--: |
| 查找 |     O(1)     |     O(n)     | O(1) | O(n) |
| 插入 |     O(1)     |     O(n)     | O(n) | O(1) |
| 删除 |     O(1)     |     O(n)     | O(n) | O(1) |

散射函数兼具数组和链表的优点，但在最坏情况下，各种操作都很慢。因此我们需要避免冲突以避免最坏情况：

1. 较低的填装因子
2. 良好的散射函数

#### 填装因子

$$
填装因子 = 散列表包含的元素数/位置总数
$$

散列表用数组来储存数据，所以需要计算数组中被占用的位置数。填装因子大于1就意味着要填入的元素总数超过了数组的位置数，一旦填装因子开始增大，就需要在散列表中添加位置，这就是resizing。

##### resizing

1. 创建一个更长的新数组，通常将数组增长一倍
2. 用hash将所有的元素都插入到这个新的散列表中

当填装因子大于0.7，就调整散列表的长度

resizing的开销很大，因此不会频繁这么做，但即使考虑到resizing所需要的时间，散列表操作所需的时间仍为O(1)

#### 散射函数

选择良好的散射函数可以让数值在数组中均匀分布，而不是在某几个位置多级链表扎堆